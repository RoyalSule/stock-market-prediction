# -*- coding: utf-8 -*-
"""Stock Price Prediction

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13oUwuMXpI296xxMXgFLKNPfiKOSrc0TC
"""

# Description: This program uses Long Short Term Memory (LSTM) to predict the stock price of NatWest Group using the past 60 day stock price.

import math
import yfinance as yf
import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Dense, LSTM
import matplotlib.pyplot as plt

nwg = yf.Ticker('NWG.L')
hist = nwg.history(period='10y')
hist

# visualise historical prices
plt.figure(figsize=(14,7))
plt.plot(hist['Close'])
plt.xlabel('Date')
plt.ylabel('Close Price USD ($)')
plt.title('Historical Prices')
plt.show()

# filter dataframe and return only 'Close' column
dataframe = hist.filter(['Close'])
# convert dataframe to numpy array
data = dataframe.values
length = math.ceil(len(data) * 0.8)
length

# data scaling
scaler = MinMaxScaler()
scaled = scaler.fit_transform(data)
scaled

# create the training data
train_data = scaled[0:length, :]
# split the training data into x_train and y_train
x_train = []
y_train = []

for i in range(60, len(train_data)):
  # append the past 60 values to x_train
  x_train.append(train_data[i-60:i, 0])
  # y_train contains the 61st value
  y_train.append(train_data[i, 0])

# convert x_train and y_train to numpy arrays
x_train, y_train = np.array(x_train), np.array(y_train)

# reshape x_train (LSTM input is 3 dimensional)
x_train = np.reshape(x_train, (x_train.shape[0], x_train.shape[1], 1))
x_train.shape

# build the LSTM model
model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(x_train.shape[1], 1)))
model.add(LSTM(50, return_sequences=False))
model.add(Dense(25))
model.add(Dense(1))

# compile the model
model.compile(optimizer='adam', loss='mean_squared_error')

# train the model
model.fit(x_train, y_train, batch_size=1, epochs=1)

# create the test data
test_data = scaled[length-60:, :]
# split the test data into x_test and y_test
x_test = []
y_test = data[length:, :]

for i in range(60, len(test_data)):
  # append the past 60 values to x_test
  x_test.append(test_data[i-60:i, 0])

# convert x_test to numpy array
x_test = np.array(x_test)

# reshape x_test
x_test = np.reshape(x_test, (x_test.shape[0], x_test.shape[1], 1))

# prediction contains the same values as y_test
prediction = model.predict(x_test)
prediction = scaler.inverse_transform(prediction)

# get the root mean squared error (RMSE)
rmse = np.sqrt(np.mean(((prediction - y_test)**2)))
rmse

# plot the data
train = dataframe[:length]
valid = dataframe[length:]
valid['Prediction'] = prediction
plt.figure(figsize=(14,7))
plt.plot(train['Close'])
plt.plot(valid[['Close', 'Prediction']])
plt.xlabel('Date')
plt.ylabel('Close Price USD ($)')
plt.title('Model')
plt.legend(['Train', 'Validation', 'Prediction'])
plt.show()

# convert dataframe to array
horizon = dataframe[-60:].values
# scale the data
horizon_scaled = scaler.transform(horizon)
# create an empty list
X_test = []
# append horizon_scaled
X_test.append(horizon_scaled)
# convert X_test to numpy array
X_test = np.array(X_test)
# reshape X_test
X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))
# get the predicted price
predicted_price = model.predict(X_test)
# undo the scaling
predicted_price = scaler.inverse_transform(predicted_price)
print(predicted_price)

